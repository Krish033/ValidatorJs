class Validator{useDefaultErrorElement=!0;throwErrors=!0;validateCheckBoxes=!1;stopEventPropagation=!0;constructor(form){this.form=form;this.shouldContainName()}
shouldContainName(){const validatables=this.getValidatables();validatables?.map((item)=>{if(item.name==null||empty(item.name)){throw new ReferenceError("Validator Inputs should contain a name attribute")}})}
getValuesFromValidatables(){const validatables=this.getValidatables();let validationArray={};validatables?.forEach((item)=>{validationArray={...validationArray,[item.name]:item.value,}});return validationArray}
getValidatables(){return[...this.form.querySelectorAll("input"),...this.form.querySelectorAll("[data-needs-validation]"),]}
getValidatableElements(){const elements=this.getValidatables();const passed=this.passesValidation();return[...elements.map((item)=>{if(!passed.includes(item.name)){return item}}),].filter((item)=>item!==undefined)}
errorElements(){this.clearErrorElements();const elements=this.getValidatableElements();const errors=this.splitErrors();elements.map((item)=>{const parent=item.parentElement;if(Object.keys(errors).includes(item?.name)){const errorElement=document.createElement("span");errorElement.classList.add("error");errorElement.setAttribute("data-validation-error",item.name);errorElement.textContent=errors[item.name];parent.appendChild(errorElement)}});return!0}
showErrorMessage(){const errorElements=this.getErrorElements();if(!errorElements.length){throw new ReferenceError("Error container not found!")}
const errors=this.splitErrors();errorElements.forEach((item)=>{item.textContent="";if(Object.keys(errors).includes(item.dataset.validationError)){item.textContent=errors[item.dataset.validationError]}});return!0}
getErrorElements(){return[...this.form.querySelectorAll("[data-validation-error]")]}
clearErrorElements(){const errorElements=this.getErrorElements();if(errorElements.length){errorElements.map((error)=>error.remove());return!0}
return!1}
passesValidation(){const inputWithTypeCheckBox=this.validateCheckBoxes?[...this.form.querySelectorAll("input[type=checkbox]")]:[];const doNotValidateElements=[...this.form.querySelectorAll("[data-passes-validation]"),...inputWithTypeCheckBox,];return[...doNotValidateElements?.map((item)=>{return item.name}),]}
getInputTypes(){const validatables=this.getValidatables();let validationArray={};validatables?.forEach((item)=>{validationArray={...validationArray,[item.name]:item.type?item.type:"textarea",}});return validationArray}
rules(){const validatables=this.getValidatables();const passes=this.passesValidation();let rulesArray={};validatables?.forEach((item)=>{if(passes.includes(item?.name)){item.setAttribute("data-validate","string")}
rulesArray={...rulesArray,[item.name]:item.dataset.validate.split("|"),}});return rulesArray}
validate(){const rules=this.rules();const data=this.getValuesFromValidatables();const fullListObject=[...Object.entries(data).map((obj)=>{return{field:obj[0],value:obj[1],rules:Array.isArray(rules[obj[0]])?rules[obj[0]]:[rules[obj[0]]],passed:this.passesValidation().includes(first(obj)),}}),];const errorArray=Rules.inputValidation(fullListObject);return errorArray}
splitErrors(){const errorsArray=this.validated();let singleErrorArray={};errorsArray.map((item,index,array)=>{const lastItem=array[index-1];if(lastItem!==undefined&&lastItem.field==item.field)return!1;if(item.error){singleErrorArray={...singleErrorArray,[item?.field]:first(Object.entries(item?.error))[1],}}});return singleErrorArray}
validated(){return[...this.validate().filter((item)=>!item.passed)]}
handleSubmit(func){const data=this.getValuesFromValidatables();const errors=this.splitErrors();if(!this.throwErrors){return func(data,{})}
if(this.useDefaultErrorElement){this.errorElements()}
if(!this.useDefaultErrorElement){this.showErrorMessage()}
if(this.stopEventPropagation&&hasLength(errors)){return!1}
return func(data,errors)}}
class Rules{static mixedRules=["required","string","number","boolean","checked","selected","min","max",];static association(){return[{name:"required",method:this.required,},{name:"string",method:this.string,},{name:"number",method:this.number,},{name:"boolean",method:this.bool,},{name:"selected",method:this.selected,},]}
static errorMessages(field,value=0){return{required:" is required",string:" should be a string",number:" should be a number",boolean:" should be a boolean",checked:" is required",selected:" should be selected",min:" should not be less than "+value+" chars",max:" should not exceed"+value+"chars",}}
static required(data){const error=Rules.errorMessages(data).required;const original=!isNull(data);return original?!0:error}
static string(data){const error=Rules.errorMessages(data).string;const original=data instanceof String;return original?!0:error}
static number(data){const error=Rules.errorMessages(data).number;const original=parseInt(data)?!0:!1;return original?!0:error}
static bool(data){const error=Rules.errorMessages(data).boolean;const original=data instanceof Boolean;return original?!0:error}
static checked(data){const error=Rules.errorMessages(data).checked;const original=data==="on";return original?!0:error}
static selected(data){const error=Rules.errorMessages(data).selected;const original=!isNull(data);return original?!0:error}
static max(data,min){const error=Rules.errorMessages(data,min).max;const original=data>=parseInt(min);return original?!0:error}
static min(data,max){const error=Rules.errorMessages(data,max).min;const original=data<=parseInt(max);return original?!0:error}
static existsInRules(item){const rules=Rules.mixedRules;if(!rules.includes(item)){return Rules.ruleNotFountException()}
return item}
static ruleNotFountException(){throw new ReferenceError("Cannot Validate with Unknown rule")}
static inputValidation(itemsArray){return itemsArray.map((item)=>{const assoc=Rules.association();const errors=item.rules.map((rule)=>{const main=assoc.filter((r)=>r.name===rule);const getError=first(main).method(item.value);let error=!0;if(getError!==!0)error=ucfirst(item.field)+getError;return getError!==!0?{[item.field]:error}:!0});return{...item,error:errors.filter((error)=>error!==!0)[0],}})}}
const ucfirst=(first)=>{return first[0].toUpperCase()+first.substring(1)};const hasLength=(object)=>{return Object.entries(object).length>0};function empty(value){if(value===""||value.trim()==="")return!0;return!1}
function isNull(item){if(item==null||item?.trim(item)==""||item===undefined)return!0;return!1}
const first=(array)=>{return array[0]};function requestValidatorEventFor(event){return new Validator(event)}
